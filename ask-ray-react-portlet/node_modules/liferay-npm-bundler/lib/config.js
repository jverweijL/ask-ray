'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.reloadConfig = reloadConfig;
exports.getOutputDir = getOutputDir;
exports.getReportFilePath = getReportFilePath;
exports.getExclusions = getExclusions;
exports.loadBabelPlugins = loadBabelPlugins;
exports.getPlugins = getPlugins;
exports.getBabelConfig = getBabelConfig;
exports.isProcessSerially = isProcessSerially;
exports.isVerbose = isVerbose;
exports.getIncludeDependencies = getIncludeDependencies;
exports.isDumpReport = isDumpReport;
exports.getVersionsInfo = getVersionsInfo;

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _resolve = require('resolve');

var _resolve2 = _interopRequireDefault(_resolve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var pluginsBaseDir = '.';
var config = loadConfig();

/**
 * Load configuration.
 * @return {Object} the configuration object
 */
function loadConfig() {
	// Load base configuration
	var config = {};

	try {
		config = (0, _readJsonSync2.default)('.npmbundlerrc');
	} catch (err) {
		if (err.code !== 'ENOENT') {
			throw err;
		}
	}

	// Apply preset if necessary
	if (config.preset) {
		var presetFile = _resolve2.default.sync(config.preset, {
			basedir: '.'
		});

		// Merge preset with base configuration
		config = Object.assign((0, _readJsonSync2.default)(presetFile), config);
		pluginsBaseDir = (0, _packages.getPackageDir)(presetFile);
	}

	// Normalize
	config.packages = config.packages || {};

	return config;
}

/**
 * Require a module using the configured plugins directory.
 * @param {String} module a module name
 * @return {Object} the required module object
 */
function configRequire(module) {
	var pluginFile = _resolve2.default.sync(module, {
		basedir: pluginsBaseDir
	});

	return require(pluginFile);
}

/**
 * Force a config reload
 * @return {void}
 */
function reloadConfig() {
	config = loadConfig();
}

/**
 * Get the configured output directory
 * @return {String} the directory path (with native separators)
 */
function getOutputDir() {
	var dir = config['output'] || 'build/resources/main/META-INF/resources';
	return _path2.default.normalize(dir);
}

/**
 * Get the path to the report file or null if no report is configured.
 * @return {String} a normalized path or null
 */
function getReportFilePath() {
	return _path2.default.join('.', 'liferay-npm-bundler-report.html');
}

/**
 * Get the configured file exclusions for a given package.
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Array} an array of glob expressions
 */
function getExclusions(pkg) {
	var exclusions = config.exclude || {};

	exclusions = exclusions[pkg.id] || exclusions[pkg.name] || exclusions['*'] || [];

	return exclusions;
}

/**
 * Load Babel plugins from a given array of presets and plugins.
 * @param {Array} presets an array of Babel preset names as defined by .babelrc
 * @param {Array} plugins an array of Babel plugins names as defined by .babelrc
 * @return {Array} the instantiated Babel plugins
 */
function loadBabelPlugins(presets, plugins) {
	var _ref;

	return (_ref = []).concat.apply(_ref, _toConsumableArray(presets.map(function (preset) {
		var presetModule = void 0;

		try {
			presetModule = configRequire(preset);
		} catch (err) {
			presetModule = configRequire('babel-preset-' + preset);
		}

		return presetModule.plugins || presetModule.default().plugins;
	}))).concat(plugins);
}

/**
 * Get the liferay-nmp-bundler plugins for a given package.
 * @param {String} phase 'pre' or 'post'
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Array} the instantiated Babel plugins
 */
function getPlugins(phase, pkg) {
	var pluginsKey = phase === 'pre' ? 'plugins' : 'post-plugins';
	var plugins = getPackageConfig(pkg, pluginsKey) || [];

	return plugins.map(function (pluginName) {
		var pluginConfig = {};

		if (Array.isArray(pluginName)) {
			pluginConfig = pluginName[1];
			pluginName = pluginName[0];
		}

		var pluginModule = configRequire('liferay-npm-bundler-plugin-' + pluginName);

		return {
			name: pluginName,
			config: pluginConfig,
			run: pluginModule.default
		};
	});
}

/**
 * Get Babel config for a given package
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Object} a Babel configuration object as defined by its API
 */
function getBabelConfig(pkg) {
	return getPackageConfig(pkg, '.babelrc') || {};
}

/**
 * Whether or not to process npm packages serially
 * @return {boolean}
 */
function isProcessSerially() {
	return config['process-serially'] || false;
}

/**
 * Whether or not to dump detailed information about what the tool is doing
 * @return {boolean}
 */
function isVerbose() {
	return config['verbose'] || false;
}

/**
 * Extra dependencies to add to the final bundle (in addition to those listed
 * under the dependencies section of package.json).
 * @return {Array} an array of package names
 */
function getIncludeDependencies() {
	return config['include-dependencies'] || [];
}

/**
 * Whether or not to dump report
 * @return {boolean}
 */
function isDumpReport() {
	return config['dump-report'] || false;
}

/**
 * Get versions information
 * @return {void}
 */
function getVersionsInfo() {
	var pkgJson = require('../package.json');

	var info = {
		'liferay-npm-bundler': pkgJson.version
	};

	info = Object.assign(info, getPluginVersions());

	return info;
}
/**
 * Get version numbers of all plugins used in the build.
 * @return {Object} a map of {plugin-name: version} values
 */
function getPluginVersions() {
	var pluginVersions = {};

	// Get preset plugin version
	if (config.preset) {
		pluginVersions[config.preset] = configRequire(config.preset + '/package.json').version;
	}

	// Get legacy package and package plugins versions
	var plugins = [];

	for (var key in config) {
		if (config.hasOwnProperty(key)) {
			plugins = concatAllPlugins(plugins, config[key]);
		}
	}

	for (var _key in config.packages) {
		if (config.packages.hasOwnProperty(_key)) {
			plugins = concatAllPlugins(plugins, config.packages[_key]);
		}
	}

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var plugin = _step.value;

			if (!pluginVersions[plugin]) {
				pluginVersions[plugin] = configRequire(plugin + '/package.json').version;
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return pluginVersions;
}

/**
 * Add version numbers for all bundler and Babel plugins listed in `cfg`.
 * @param {Array} plugins the array of currently collected plugins
 * @param {Array} cfg a configuration subsection
 * @return {Array} the concatenated array of collected plugins
 */
function concatAllPlugins(plugins, cfg) {
	if (cfg) {
		plugins = concatBundlerPlugins(plugins, cfg['plugins']);
		plugins = concatBundlerPlugins(plugins, cfg['post-plugins']);
		plugins = concatBabelPlugins(plugins, cfg['.babelrc']);
	}

	return plugins;
}

/**
 * Add version numbers for all bundler plugins listed in `cfg`.
 * @param {Array} plugins the array of currently collected plugins
 * @param {Array} cfg a configuration subsection
 * @return {Array} the concatenated array of collected plugins
 */
function concatBundlerPlugins(plugins, cfg) {
	if (!cfg) {
		return plugins;
	}

	return plugins.concat(cfg.map(function (name) {
		if (Array.isArray(name)) {
			name = name[0];
		}

		return 'liferay-npm-bundler-plugin-' + name;
	}));
}

/**
 * Add version numbers for all Babel plugins listed in `cfg`.
 * @param {Array} plugins the array of currently collected plugins
 * @param {Array} cfg a configuration subsection
 * @return {Array} the concatenated array of collected plugins
 */
function concatBabelPlugins(plugins, cfg) {
	if (!cfg) {
		return plugins;
	}

	var babelPresets = cfg['presets'];
	var babelPlugins = cfg['plugins'];

	if (babelPresets) {
		plugins = plugins.concat(babelPresets.map(function (name) {
			try {
				configRequire(name);
				return name;
			} catch (err) {
				return 'babel-preset-' + name;
			}
		}));
	}

	if (babelPlugins) {
		plugins = plugins.concat(babelPlugins.map(function (name) {
			if (Array.isArray(name)) {
				name = name[0];
			}

			try {
				configRequire(name);
				return name;
			} catch (err) {
				return 'babel-plugin-' + name;
			}
		}));
	}

	return plugins;
}

/**
 * Get a configuration for a specific package. This method looks in the packages
 * section, then at root in the precedence order: first package id, then package
 * name.
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @param  {String} key the key name
 * @return {Object} a configuration object
 */
function getPackageConfig(pkg, key) {
	var pkgConfig = void 0;

	if (config.packages[pkg.id] && config.packages[pkg.id][key]) {
		pkgConfig = config.packages[pkg.id][key];
	} else if (config.packages[pkg.name] && config.packages[pkg.name][key]) {
		pkgConfig = config.packages[pkg.name][key];
	} else if (config[pkg.id] && config[pkg.id][key]) {
		pkgConfig = config[pkg.id][key];
	} else if (config[pkg.name] && config[pkg.name][key]) {
		pkgConfig = config[pkg.name][key];
	} else if (config['*'] && config['*'][key]) {
		pkgConfig = config['*'][key];
	}

	return pkgConfig;
}
//# sourceMappingURL=config.js.map