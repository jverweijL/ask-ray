'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Report = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _html = require('./html');

var _analytics = require('./analytics');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A Report holds data describing a execution of the liferay-npm-bundler so that
 * it can be dump as an HTML report.
 * @type {Report}
 */
var Report = exports.Report = function () {
	/**
  * Constructor
  */
	function Report() {
		_classCallCheck(this, Report);

		this._executionDate = new Date();
		this._versionsInfo = {};
		this._packages = {};
		this._warnings = [];
	}

	/**
  * Return an HTML string with the information contained in this report.
  * @return {String} an HTML string
  */


	_createClass(Report, [{
		key: 'toHtml',
		value: function toHtml() {
			return (0, _html.htmlDump)(this);
		}

		/**
   * Dump report information to insight package so that it gets exported to
   * our Google Analytics account.
   * @return {void}
   */

	}, {
		key: 'sendAnalytics',
		value: function sendAnalytics() {
			return (0, _analytics.analyticsDump)(this);
		}

		/**
   * Register execution time.
   * @param  {Array} hrtime the time it took to execute
   * @return {void}
   */

	}, {
		key: 'executionTime',
		value: function executionTime(hrtime) {
			this._executionTime = hrtime;
		}

		/**
   * Register a warning.
   * @param  {String} message the warning message
   * @param  {boolean} unique set to true if you want this warning to be deduped
   * @return {void}
   */

	}, {
		key: 'warn',
		value: function warn(message) {
			var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { unique: false },
			    unique = _ref.unique;

			if (unique && this._warnings.find(function (item) {
				return item === message;
			})) {
				return;
			}

			this._warnings.push(message);
		}

		/**
   * Register a versions hash describing the packages and versions used by the
   * build process.
   * @param  {Object} info a hash or (package,version) pairs
   * @return {void}
   */

	}, {
		key: 'versionsInfo',
		value: function versionsInfo(info) {
			this._versionsInfo = info;
		}

		/**
   * Register a linked dependency found in the root package.json.
   * @param  {String} packageName package name
   * @param  {String} packageLink the link to the package
   * @param  {String} packageVersion package version
   * @return {void}
   */

	}, {
		key: 'linkedDependency',
		value: function linkedDependency(packageName, packageLink, packageVersion) {
			var pkgId = packageName + '@' + packageVersion;
			var pkg = this._getPackage(pkgId);

			pkg.link = packageLink;
		}

		/**
   * Register the list of dependencies detected in this build.
   * @param  {Array} deps an array of package descriptors (with id, name and
   * 						version fields)
   * @return {void}
   */

	}, {
		key: 'dependencies',
		value: function dependencies(deps) {
			var _this = this;

			deps.forEach(function (dep) {
				var pkg = _this._getPackage(dep.id);

				Object.assign(pkg, dep);
			});

			// Remove all pre-registered packages that are not in the deps array
			Object.keys(this._packages).forEach(function (pkgId) {
				var pkg = _this._packages[pkgId];

				if (!pkg.id) {
					delete _this._packages[pkgId];
				}
			});
		}

		/**
   * Register a package copy action.
   * @param  {Object} pkg a package descriptor
   * @param  {Array} allFiles the list of all files in the package
   * @param  {Array} copiedFiles the list of files copied to the target
   * @param  {Array} exclusions the list of configured file exclusions
   * @return {void}
   */

	}, {
		key: 'packageCopy',
		value: function packageCopy(pkg, allFiles, copiedFiles, exclusions) {
			var rpkg = this._getPackage(pkg.id);

			Object.assign(rpkg, {
				allFiles: allFiles,
				copiedFiles: copiedFiles,
				exclusions: exclusions
			});
		}

		/**
   * Register a liferay-npm-bundler plugin execution.
   * @param  {String} phase run phase (pre or post)
   * @param  {Object} pkg package descriptor
   * @param  {Object} plugin plugin descriptor (with config and run fields)
   * @param  {PluginLogger} logger the logger cotaining the process messages
   * @return {void}
   */

	}, {
		key: 'packageProcessBundlerPlugin',
		value: function packageProcessBundlerPlugin(phase, pkg, plugin, logger) {
			var pkgProcess = this._getPackageProcess(pkg.id);

			pkgProcess[phase][plugin.name] = {
				plugin: plugin,
				logger: logger
			};
		}

		/**
   * Register a Babel execution config.
   * @param  {Object} pkg package descriptor
   * @param  {Object} babelConfig the Babel config object
   * @return {void}
   */

	}, {
		key: 'packageProcessBabelConfig',
		value: function packageProcessBabelConfig(pkg, babelConfig) {
			var _getPackageProcess2 = this._getPackageProcess(pkg.id),
			    babel = _getPackageProcess2.babel;

			babel.config = babelConfig;
		}

		/**
   * Register a Babel file process.
   * @param  {Object} pkg package descriptor
   * @param  {String} filePath the file path
   * @param  {PluginLogger} logger the logger cotaining the process messages
   * @return {void}
   */

	}, {
		key: 'packageProcessBabelRun',
		value: function packageProcessBabelRun(pkg, filePath, logger) {
			var _getPackageProcess3 = this._getPackageProcess(pkg.id),
			    babel = _getPackageProcess3.babel;

			babel.files[filePath] = { logger: logger };
		}

		/**
   * Get a package slot and create it if missing.
   * @param  {String} pkgId the package id
   * @return {Object} a package slot
   */

	}, {
		key: '_getPackage',
		value: function _getPackage(pkgId) {
			var pkg = this._packages[pkgId];

			if (!pkg) {
				pkg = this._packages[pkgId] = {
					allFiles: [],
					copiedFiles: [],
					exclusions: []
				};

				this._getPackageProcess(pkgId);
			}

			return pkg;
		}

		/**
   * Get a package process slot and create it if missing.
   * @param  {String} pkgId the package id
   * @return {Object} a package process slot
   */

	}, {
		key: '_getPackageProcess',
		value: function _getPackageProcess(pkgId) {
			var rpkg = this._getPackage(pkgId);

			rpkg.process = rpkg.process || {
				pre: {},
				babel: {
					config: {},
					files: {}
				},
				post: {}
			};

			return rpkg.process;
		}
	}]);

	return Report;
}();

var report = new Report();

exports.default = report;
//# sourceMappingURL=index.js.map