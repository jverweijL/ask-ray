'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

exports.default = function (args) {
	var versionsInfo = config.getVersionsInfo();

	if (args[0] === '-v' || args[0] === '--version') {
		console.log(JSON.stringify(versionsInfo, null, 2));
		return;
	} else {
		_report2.default.versionsInfo(versionsInfo);
	}

	insight.init().then(run);
};

var _babelCore = require('babel-core');

var babel = _interopRequireWildcard(_babelCore);

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _packages = require('liferay-npm-build-tools-common/lib/packages');

var _pluginLogger = require('liferay-npm-build-tools-common/lib/plugin-logger');

var _pluginLogger2 = _interopRequireDefault(_pluginLogger);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _prettyTime = require('pretty-time');

var _prettyTime2 = _interopRequireDefault(_prettyTime);

var _readJsonSync = require('read-json-sync');

var _readJsonSync2 = _interopRequireDefault(_readJsonSync);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _config = require('./config');

var config = _interopRequireWildcard(_config);

var _insight = require('./insight');

var insight = _interopRequireWildcard(_insight);

var _dependencies = require('./dependencies');

var _log = require('./log');

var log = _interopRequireWildcard(_log);

var _report = require('./report');

var _report2 = _interopRequireDefault(_report);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Default entry point for the liferay-npm-bundler.
 * @param {Array} args command line arguments
 * @return {void}
 */


/**
 * Real tool execution
 * @return {void}
 */
function run() {
	// Create work directories
	var outputDir = _path2.default.resolve(config.getOutputDir());
	_fsExtra2.default.mkdirsSync(_path2.default.join(outputDir, 'node_modules'));

	var promises = [];

	// Copy project's package.json
	promises.push(copyRootPackageJson(outputDir));

	// Grab NPM dependencies
	var pkgs = (0, _dependencies.getPackageDependencies)('.', config.getIncludeDependencies());
	pkgs = Object.keys(pkgs).map(function (id) {
		return pkgs[id];
	});
	pkgs = pkgs.filter(function (pkg) {
		return pkg.dir != '.';
	});

	_report2.default.dependencies(pkgs);

	// Process NPM dependencies
	var start = process.hrtime();

	log.info('Bundling ' + pkgs.length + ' dependencies...');

	if (config.isProcessSerially()) {
		_report2.default.warn('Option process-serially is on: this may degrade build performance.');

		promises.push(iterateSerially(pkgs, function (pkg) {
			return bundlePackage(pkg, outputDir);
		}));
	} else {
		promises.push.apply(promises, _toConsumableArray(pkgs.map(function (pkg) {
			return bundlePackage(pkg, outputDir);
		})));
	}

	Promise.all(promises).then(function () {
		var hrtime = process.hrtime(start);

		_report2.default.executionTime(hrtime);

		log.info('Bundling took ' + (0, _prettyTime2.default)(hrtime));

		// Send report analytics data
		_report2.default.sendAnalytics();

		// Write report if requested
		if (config.isDumpReport()) {
			_fsExtra2.default.writeFileSync(config.getReportFilePath(), _report2.default.toHtml());
			log.info('Report written to ' + config.getReportFilePath());
		}
	}).catch(function (err) {
		log.error(err);
		process.exit(1);
	});
}

/**
 * Copy project root package.json file to output directory.
 * @param {String} outputDir the output directory path
 * @return {Promise} a Promise fulfilled when the copy has been finished
 */
function copyRootPackageJson(outputDir) {
	var pkgJson = (0, _readJsonSync2.default)('package.json');

	['dependencies', 'devDependencies'].forEach(function (scope) {
		if (pkgJson[scope] != null) {
			Object.keys(pkgJson[scope]).forEach(function (depName) {
				var depVersion = pkgJson[scope][depName];

				if (_semver2.default.validRange(depVersion) == null) {
					var depPkgJsonPath = _path2.default.join(depVersion.substring(5), 'package.json');

					var depPkgJson = (0, _readJsonSync2.default)(depPkgJsonPath);

					pkgJson[scope][depName] = depPkgJson.version;

					_report2.default.linkedDependency(depName, depVersion, depPkgJson.version);
				}
			});
		}
	});

	return _fsExtra2.default.writeJson(_path2.default.join(outputDir, 'package.json'), pkgJson, {
		spaces: 2
	});
}

/**
 * Iterate through the elements of an array applying an async process serially
 * to each one of them.
 * @param {Array} values array of values to be iterated
 * @param {function} asyncProcess the async process (that returns a Promise) to
 *        be executed on each value
 * @return {Promise} a Promise that is resolved as soon as the iteration
 *         finishes
 */
function iterateSerially(values, asyncProcess) {
	return new Promise(function (resolve) {
		if (values.length == 0) {
			resolve();
			return;
		}

		var val = values[0];

		var p = asyncProcess(val);

		p.then(function () {
			iterateSerially(values.slice(1), asyncProcess).then(function () {
				resolve();
			});
		});
	});
}

/**
 * Bundle a npm package
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @param {String} outputDir directory where bundled packages are placed
 * @return {Promise} a promise that is fulfilled when the package is bundled
 */
function bundlePackage(pkg, outputDir) {
	var outPkgDir = _path2.default.join(outputDir, 'node_modules', (0, _packages.getPackageTargetDir)(pkg.name, pkg.version));

	try {
		if (_fsExtra2.default.statSync(outPkgDir).isDirectory()) {
			log.debug('Skipping ' + pkg.id + ' (already bundled)');
			return Promise.resolve();
		}
	} catch (err) {}

	log.debug('Bundling ' + pkg.id);

	_fsExtra2.default.mkdirsSync(outPkgDir);

	return copyPackage(pkg, outPkgDir).then(function () {
		return pkg.dir = outPkgDir;
	}).then(function () {
		return processPackage('pre', pkg);
	}).then(function () {
		return runBabel(pkg);
	}).then(function () {
		return processPackage('post', pkg);
	}).then(function () {
		return log.debug('Bundled ' + pkg.id);
	});
}

/**
 * Copy an NPM package to output directory.
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @param {String} dir the output directory path
 * @return {Promise} a Promise fulfilled when the copy has been finished
 */
function copyPackage(pkg, dir) {
	var rawGlobs = [pkg.dir + '/**/*', '!' + pkg.dir + '/node_modules/**/*'];

	var exclusions = config.getExclusions(pkg);

	var globs = rawGlobs.concat(exclusions.map(function (exclusion) {
		return '!' + pkg.dir + '/' + exclusion;
	}));

	return (0, _globby2.default)(globs).then(function (paths) {
		var fileFilter = function fileFilter(path) {
			return _fsExtra2.default.statSync(path).isFile();
		};
		var relativePathMapper = function relativePathMapper(path) {
			return path.substring(pkg.dir.length + 1);
		};

		paths = paths.filter(fileFilter).map(relativePathMapper);

		var rawPaths = _globby2.default.sync(rawGlobs).filter(fileFilter).map(relativePathMapper);

		_report2.default.packageCopy(pkg, rawPaths, paths, exclusions);

		var promises = paths.map(function (path) {
			return _fsExtra2.default.copy(pkg.dir + '/' + path, dir + '/' + path);
		});

		return Promise.all(promises);
	});
}

/**
 * Process an NPM package with the configured liferay-nmp-bundler plugins. This
 * function is called two times (known as phases) per package: one before Babel
 * runs and one after.
 * @param {String} phase 'pre' or 'post' depending on what phase we are in
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function processPackage(phase, pkg) {
	return new Promise(function (resolve, reject) {
		var pkgJsonPath = _path2.default.join(pkg.dir, 'package.json');
		var pkgJson = (0, _readJsonSync2.default)(pkgJsonPath);

		var state = {
			pkgJson: pkgJson
		};

		try {
			config.getPlugins(phase, pkg).forEach(function (plugin) {
				var logger = new _pluginLogger2.default();

				plugin.run({ pkg: pkg, config: plugin.config, log: logger }, state);

				_report2.default.packageProcessBundlerPlugin(phase, pkg, plugin, logger);
			});
		} catch (err) {
			reject(err);
		}

		_fsExtra2.default.writeFileSync(pkgJsonPath, JSON.stringify(state.pkgJson, '', 2));

		resolve();
	});
}

/**
 * Run Babel on a package.
 * @param {Object} pkg the package descriptor hash containing id, name, version
 *        and dir fields
 * @return {Promise} a Promise fulfilled when the process has been finished
 */
function runBabel(pkg) {
	// Make a copy of the package's Babel configuration
	var babelConfig = Object.assign({}, config.getBabelConfig(pkg));

	// Tune babel config
	babelConfig.babelrc = false;
	babelConfig.only = '**/*';
	if (babelConfig.sourceMaps === undefined) {
		babelConfig.sourceMaps = true;
	}

	// Report a copy of the package's Babel configuration before loading plugins
	_report2.default.packageProcessBabelConfig(pkg, Object.assign({}, babelConfig));

	// Intercept presets and plugins to load them from here
	babelConfig.plugins = config.loadBabelPlugins(babelConfig.presets || [], babelConfig.plugins || []);
	babelConfig.presets = [];

	// Run babel through it
	return (0, _globby2.default)([pkg.dir + '/**/*.js']).then(function (filePaths) {
		var promises = filePaths.map(function (filePath) {
			return new Promise(function (resolve) {
				var logger = new _pluginLogger2.default();

				_pluginLogger2.default.set(filePath, logger);

				babel.transformFile(filePath, Object.assign({
					filenameRelative: filePath
				}, babelConfig), function (err, result) {
					// Generate and/or log results
					if (err) {
						log.error('Babel failed processing', filePath.substr(filePath.indexOf(pkg.id)) + ':', 'it will be copied verbatim (see report file for more info)');

						logger.error('babel', err);

						_report2.default.warn('Babel failed processing some .js files: check details of Babel transformations for more info.', { unique: true });
					} else {
						var fileName = _path2.default.basename(filePath);

						_fsExtra2.default.writeFileSync(filePath, result.code + '\n' + ('//# sourceMappingURL=' + fileName + '.map'));

						_fsExtra2.default.writeFileSync(filePath + '.map', JSON.stringify(result.map));
					}

					// Report result of babel run
					_report2.default.packageProcessBabelRun(pkg, filePath.substr(filePath.indexOf(pkg.id) + pkg.id.length + 1), logger);

					// Get rid of logger
					_pluginLogger2.default.delete(filePath);

					// Resolve promise
					resolve();
				});
			});
		});

		return Promise.all(promises);
	});
}
//# sourceMappingURL=index.js.map