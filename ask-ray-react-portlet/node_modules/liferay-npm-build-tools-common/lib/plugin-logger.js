'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * An object to hold babel or liferay-npm-bundler plugin messages.
 * @type {PluginLogger}
 */
var PluginLogger = function () {
	/**
  * Construct empty logger with no messages
  */
	function PluginLogger() {
		_classCallCheck(this, PluginLogger);

		this._msgs = [];
	}

	/**
  * Log an informational message
  * @param {String} source the identifier for the source of the message
  * @param {Array} things the objects or strings to print
  * @return {void}
  */


	_createClass(PluginLogger, [{
		key: 'info',
		value: function info(source) {
			for (var _len = arguments.length, things = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				things[_key - 1] = arguments[_key];
			}

			this._msgs.push({
				source: source,
				level: 'info',
				things: things
			});
		}

		/**
   * Log an error message
   * @param {String} source the identifier for the source of the message
   * @param {Array} things the objects or strings to print
   * @return {void}
   */

	}, {
		key: 'error',
		value: function error(source) {
			for (var _len2 = arguments.length, things = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				things[_key2 - 1] = arguments[_key2];
			}

			this._msgs.push({
				source: source,
				level: 'error',
				things: things
			});
		}

		/**
   * Get the list of messages
   * @return {Array} an array containing one object per messages (with fields: source, level and things)
   */

	}, {
		key: 'toString',


		/**
   * Return a printable string representation of the messages logged till now
   * @return {String} a string containing one line per message
   */
		value: function toString() {
			return this._msgs.reduce(function (str, _ref) {
				var source = _ref.source,
				    level = _ref.level,
				    things = _ref.things;
				return '' + str + source + ':' + level + ': ' + things.join(' ') + '\n';
			}, '');
		}

		/**
   * Return an HTML string representation of the messages logged till now
   * @return {String} HTML containing one line (<br> separated) per message
   */

	}, {
		key: 'toHtml',
		value: function toHtml() {
			return this._msgs.reduce(function (str, _ref2) {
				var source = _ref2.source,
				    level = _ref2.level,
				    things = _ref2.things;
				return '' + str + source + ':' + level + ': ' + things.join(' ') + '<br>';
			}, '');
		}
	}, {
		key: 'messages',
		get: function get() {
			return this._msgs;
		}
	}]);

	return PluginLogger;
}();

exports.default = PluginLogger;


global._PluginLogger_ = global._PluginLogger_ || {};

/**
 * Set the logger for a given key. This is used to pass loggers from the
 * liferay-npm-bundler core to the Babel plugins because Babel's API doesn't
 * allow any way to pass per-file custom values to plugins.
 * @param  {String} key the key to identify the logger (usually a file path)
 * @param  {PluginLogger} logger the logger
 * @return {void}
 */
PluginLogger.set = function (key, logger) {
	global._PluginLogger_[key] = logger;
};

/**
 * Get the logger for a given key. This is used to pass loggers from the
 * liferay-npm-bundler core to the Babel plugins because Babel's API doesn't
 * allow any way to pass per-file custom values to plugins.
 * @param  {String|Object} key the key to identify the logger (usually a file path). You can also pass the state object
 *  						   passed to Babel plugins and it will be automatically dereferenced.
 * @return {PluginLogger} the logger
 */
PluginLogger.get = function (key) {
	if (key.file && key.file.opts && key.file.opts.filenameRelative) {
		key = key.file.opts.filenameRelative;
	}

	return global._PluginLogger_[key] || new PluginLogger();
};

/**
 * Delete the logger for a given key. This is used to pass loggers from the
 * liferay-npm-bundler core to the Babel plugins because Babel's API doesn't
 * allow any way to pass per-file custom values to plugins.
 * @param  {String} key the key to identify the logger (usually a file path)
 * @return {void}
 */
PluginLogger.delete = function (key) {
	delete global._PluginLogger_[key];
};
//# sourceMappingURL=plugin-logger.js.map